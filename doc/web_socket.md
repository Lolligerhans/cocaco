# WebSocket

`WebSocket`s implement the WebSocket [protocol][RFC6455]. They are a lean way
for live data transfer between client and server. Host websites may send data
for every click or action, and receive updates to the game state from the
server.

## Hook

Clients use the `WebSocket` JavaScript constructor to instantiate WebSocket
connections. We inject JavaScript into the `"MAIN"` [world][WORLD] at
`"document_start"` to decorate the WebSocket interface. Our decoration then
communicates all invocations to content-scripts.

We use "frame" to refer to data native to WebSocket level, both in native and
deserialized encodings.

## WebSocket interactions

### Observe traffic

Observed frames are accessed through the `Reparse` module. This goes for
communication in both directions. Any other module wanting to access data
registers a "reparser" with this module. On every newly observed frame, Reparse
will invoke all active reparsers in order of registration.

Reparsers are registered with a callback. The callback function implements the
user's logic. It returns instructions for the Reparse module on how to proceed
with the frame: If setting `isDone` to `true`, the reparser is removed. If
`modifiedFrame` is defined, the frame is replaced by its value. If
`modifiedFrame` is `null` the frame is intercepted, preventing the host, and all
remaining reparsers from seeing it.

### Generate traffic

New frames are generated by instantiating the `Resend` module. Resend implements
an interface to send messages to the host server. This includes registering
reparsers to obtain sequence numbers and other data required for correct
formatting.

To inject our own frames into the client→server connection we adjust outgoing
sequence numbers to remain consistent. This prevents the automatic reload that
would otherwise be triggered on the next frame with then-invalid sequence
number. Reloads would cause strain the host servers.

In order to avoid sequence number confusion, traffic must be injected outside of
`WebSocket.prototype.send()`. The sequence number of our injected frames must
already be adjusted; changing it in a reparser would be too late.

I think the check-for-equality happens before invoking send, the increment
happens after. (?)

### Frame queue

We may consider two courses of action when some module wants to inject frames.

1. Inject immediately but opaque to our method of observation.
2. Inject delayed, but transparently.

We choose the latter. Thus, reparsing will treat our injected frames as-if
coming from the host. We could include cues indicating the origin of frames in
the frames themselves. We avoid this to prevent confusion in the host backend.

This choice requires buffering frames until all reparsers for the current frame
have concluded. Otherwise the remaining reparser perceive the injected message
out of order, appearing before the frame causing it.

The `FrameQueue` module implements frame buffering.

<!--
 !  ╭─────────────────────────────────────────────────────────╮
 !  │ Links                                                   │
 !  ╰─────────────────────────────────────────────────────────╯
-->

[RFC6455]: https://www.rfc-editor.org/rfc/rfc6455.html#section-5 "RFC: The WebSocket Protocol"
[WORLD]: https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/manifest.json/content_scripts "MDN Web Docs: content scripts"
